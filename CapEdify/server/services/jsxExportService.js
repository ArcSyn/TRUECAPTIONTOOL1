/**
 * JSX Export Service for After Effects
 * Converts SRT captions to After Effects JSX scripts with styling and scene support
 */

const fs = require('fs').promises;
const path = require('path');

class JSXExportService {
  constructor() {
    this.defaultStyles = {
      modern: {
        font: "Arial-Bold", 
        fontSize: 65,
        color: [1, 1, 1], // White
        strokeColor: [0, 0, 0], // Black
        strokeWidth: 3,
        position: [0.5, 0.85], // Relative to comp (center bottom)
        justification: "CENTER_JUSTIFY",
        animation: "fadeIn",
        shadow: true,
        shadowColor: [0, 0, 0, 0.7],
        shadowDistance: 5
      },
      minimal: {
        font: "Helvetica-Light",
        fontSize: 48,
        color: [1, 1, 1],
        strokeColor: null,
        strokeWidth: 0,
        position: [0.5, 0.9],
        justification: "CENTER_JUSTIFY",
        animation: "none",
        shadow: false
      },
      bold: {
        font: "Impact",
        fontSize: 72,
        color: [1, 1, 0], // Yellow
        strokeColor: [0, 0, 0],
        strokeWidth: 4,
        position: [0.5, 0.8],
        justification: "CENTER_JUSTIFY",
        animation: "slideUp",
        shadow: true,
        shadowColor: [0, 0, 0, 0.8],
        shadowDistance: 8
      }
    };
  }

  /**
   * Parse SRT content into caption objects
   */
  parseSRT(srtContent) {
    const captions = [];
    const blocks = srtContent.trim().split(/\n\s*\n/);
    
    for (const block of blocks) {
      const lines = block.trim().split('\n');
      if (lines.length >= 3) {
        const index = parseInt(lines[0]);
        const timeRange = lines[1];
        const text = lines.slice(2).join(' ');
        
        // Parse time format: 00:00:10,500 --> 00:00:13,240
        const timeMatch = timeRange.match(/(\d{2}):(\d{2}):(\d{2}),(\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2}),(\d{3})/);
        if (timeMatch) {
          const startTime = this.parseTime(timeMatch[1], timeMatch[2], timeMatch[3], timeMatch[4]);
          const endTime = this.parseTime(timeMatch[5], timeMatch[6], timeMatch[7], timeMatch[8]);
          
          captions.push({
            id: index,
            startTime,
            endTime,
            text: text.replace(/<[^>]*>/g, ''), // Remove HTML tags
            duration: endTime - startTime
          });
        }
      }
    }
    
    return captions;
  }

  /**
   * Convert time components to seconds
   */
  parseTime(hours, minutes, seconds, milliseconds) {
    return parseInt(hours) * 3600 + 
           parseInt(minutes) * 60 + 
           parseInt(seconds) + 
           parseInt(milliseconds) / 1000;
  }

  /**
   * Break captions into scenes based on gaps
   */
  breakIntoScenes(captions, gapThreshold = 2.0) {
    if (!captions.length) return [];
    
    const scenes = [];
    let currentScene = [captions[0]];
    
    for (let i = 1; i < captions.length; i++) {
      const gap = captions[i].startTime - captions[i - 1].endTime;
      
      if (gap > gapThreshold) {
        // Start new scene
        scenes.push({
          id: scenes.length + 1,
          startTime: currentScene[0].startTime,
          endTime: currentScene[currentScene.length - 1].endTime,
          captions: currentScene,
          duration: currentScene[currentScene.length - 1].endTime - currentScene[0].startTime
        });
        currentScene = [captions[i]];
      } else {
        currentScene.push(captions[i]);
      }
    }
    
    // Add the last scene
    if (currentScene.length > 0) {
      scenes.push({
        id: scenes.length + 1,
        startTime: currentScene[0].startTime,
        endTime: currentScene[currentScene.length - 1].endTime,
        captions: currentScene,
        duration: currentScene[currentScene.length - 1].endTime - currentScene[0].startTime
      });
    }
    
    return scenes;
  }

  /**
   * Generate After Effects JSX code
   */
  generateJSX(captions, options = {}) {
    const {
      projectName = 'Caption Project',
      styleName = 'modern',
      compWidth = 1920,
      compHeight = 1080,
      compDuration = null,
      sceneMode = false
    } = options;

    const style = this.defaultStyles[styleName] || this.defaultStyles.modern;
    const scenes = sceneMode ? this.breakIntoScenes(captions) : null;
    
    if (sceneMode && scenes) {
      return this.generateSceneBasedJSX(scenes, style, options);
    }
    
    return this.generateSingleJSX(captions, style, options);
  }

  /**
   * Generate single JSX file with all captions
   */
  generateSingleJSX(captions, style, options) {
    const { projectName, compWidth = 1920, compHeight = 1080 } = options;
    
    return `// After Effects Caption Script - ${projectName}
// Generated by CaptionFlow Enhanced
// Style: ${style.font || 'Default'}

function addCaptions() {
    var comp = app.project.activeItem;
    
    if (!comp || !(comp instanceof CompItem)) {
        alert("Please select a composition first.");
        return;
    }
    
    app.beginUndoGroup("Add Enhanced Captions");
    
    try {
        // Caption data
        var captions = ${JSON.stringify(captions, null, 8)};
        
        // Style configuration
        var style = ${JSON.stringify(style, null, 8)};
        
        for (var i = 0; i < captions.length; i++) {
            var caption = captions[i];
            var textLayer = comp.layers.addText(caption.text);
            textLayer.name = "Caption " + (i + 1) + " - " + caption.text.substring(0, 20) + "...";
            
            // Set timing
            textLayer.inPoint = caption.startTime;
            textLayer.outPoint = caption.endTime;
            
            // Apply text styling
            var textProp = textLayer.property("Source Text");
            var textDocument = textProp.value;
            
            textDocument.font = style.font;
            textDocument.fontSize = style.fontSize;
            textDocument.fillColor = style.color;
            
            if (style.strokeWidth > 0 && style.strokeColor) {
                textDocument.strokeColor = style.strokeColor;
                textDocument.strokeWidth = style.strokeWidth;
                textDocument.strokeOverFill = true;
            }
            
            textDocument.justification = ParagraphJustification[style.justification];
            textProp.setValue(textDocument);
            
            // Position
            var posX = style.position[0] * comp.width;
            var posY = style.position[1] * comp.height;
            textLayer.property("Position").setValue([posX, posY]);
            
            // Add shadow if enabled
            if (style.shadow) {
                var dropShadow = textLayer.property("Effects").addProperty("Drop Shadow");
                dropShadow.property("Opacity").setValue(180);
                dropShadow.property("Direction").setValue(135);
                dropShadow.property("Distance").setValue(style.shadowDistance || 5);
                dropShadow.property("Softness").setValue(10);
            }
            
            // Add animation based on style
            if (style.animation === "fadeIn") {
                var opacity = textLayer.property("Opacity");
                opacity.setValueAtTime(textLayer.inPoint, 0);
                opacity.setValueAtTime(textLayer.inPoint + 0.3, 100);
                opacity.setValueAtTime(textLayer.outPoint - 0.3, 100);
                opacity.setValueAtTime(textLayer.outPoint, 0);
            } else if (style.animation === "slideUp") {
                var position = textLayer.property("Position");
                var startPos = [posX, posY + 50];
                var endPos = [posX, posY];
                position.setValueAtTime(textLayer.inPoint, startPos);
                position.setValueAtTime(textLayer.inPoint + 0.5, endPos);
            }
        }
        
        app.endUndoGroup();
        alert("Successfully added " + captions.length + " captions!");
        
    } catch (error) {
        app.endUndoGroup();
        alert("Error adding captions: " + error.toString());
    }
}

// Execute the function
addCaptions();
`;
  }

  /**
   * Generate scene-based JSX files
   */
  generateSceneBasedJSX(scenes, style, options) {
    const { projectName } = options;
    const jsxFiles = {};
    
    // Master JSX that imports all scenes
    jsxFiles['master.jsx'] = this.generateMasterJSX(scenes, projectName);
    
    // Individual scene JSX files
    scenes.forEach((scene, index) => {
      const sceneNumber = String(index + 1).padStart(3, '0');
      jsxFiles[`scene_${sceneNumber}.jsx`] = this.generateSingleJSX(
        scene.captions, 
        style, 
        { ...options, projectName: `${projectName} - Scene ${scene.id}` }
      );
    });
    
    return jsxFiles;
  }

  /**
   * Generate master JSX that can import all scenes
   */
  generateMasterJSX(scenes, projectName) {
    return `// Master Scene Controller - ${projectName}
// Generated by CaptionFlow Enhanced

function importAllScenes() {
    alert("Master scene controller loaded. Import individual scene files to add captions.");
    
    var sceneInfo = ${JSON.stringify(scenes.map(scene => ({
      id: scene.id,
      startTime: scene.startTime,
      endTime: scene.endTime,
      duration: scene.duration,
      captionCount: scene.captions.length
    })), null, 4)};
    
    var info = "Scene Breakdown:\\n";
    for (var i = 0; i < sceneInfo.length; i++) {
        var scene = sceneInfo[i];
        info += "Scene " + scene.id + ": " + 
                scene.startTime.toFixed(1) + "s - " + 
                scene.endTime.toFixed(1) + "s (" + 
                scene.captionCount + " captions)\\n";
    }
    
    alert(info);
}

importAllScenes();
`;
  }

  /**
   * Export captions to JSX format(s)
   */
  async exportToJSX(transcriptionId, options = {}) {
    try {
      // This would typically fetch from database
      // For now, we'll assume captions are passed in options
      const { captions, srtContent } = options;
      
      let captionData = captions;
      if (!captionData && srtContent) {
        captionData = this.parseSRT(srtContent);
      }
      
      if (!captionData || captionData.length === 0) {
        throw new Error('No caption data available for export');
      }
      
      const jsxResult = this.generateJSX(captionData, options);
      
      return {
        success: true,
        data: jsxResult,
        metadata: {
          captionCount: captionData.length,
          totalDuration: captionData[captionData.length - 1]?.endTime || 0,
          style: options.styleName || 'modern',
          sceneMode: options.sceneMode || false
        }
      };
      
    } catch (error) {
      console.error('JSX Export Error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Get available styles
   */
  getAvailableStyles() {
    return Object.keys(this.defaultStyles).map(key => ({
      name: key,
      displayName: key.charAt(0).toUpperCase() + key.slice(1),
      config: this.defaultStyles[key]
    }));
  }
}

module.exports = new JSXExportService();
