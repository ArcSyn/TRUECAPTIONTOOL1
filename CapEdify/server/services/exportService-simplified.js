// Simplified export service for generating multiple caption formats
// Works with in-memory storage instead of database

class ExportServiceSimplified {
  
  constructor() {
    // This will be injected from the main server
    this.transcriptionsMap = null;
  }

  setTranscriptionsMap(map) {
    this.transcriptionsMap = map;
  }

  /**
   * Generate SRT (SubRip Text) format
   * Most common subtitle format for video editors
   */
  async exportToSRT(transcriptionId) {
    const transcription = this.getTranscription(transcriptionId);
    const segments = transcription.result.segments;
    
    let srtContent = '';
    
    segments.forEach((segment, index) => {
      const sequenceNumber = index + 1;
      const startTime = this.formatSRTTime(segment.start);
      const endTime = this.formatSRTTime(segment.end);
      const text = segment.text.trim();
      
      srtContent += `${sequenceNumber}\n`;
      srtContent += `${startTime} --> ${endTime}\n`;
      srtContent += `${text}\n\n`;
    });
    
    return srtContent.trim();
  }

  /**
   * Generate JSX format for After Effects
   * Used by video creators for motion graphics
   */
  async exportToJSX(transcriptionId) {
    const transcription = this.getTranscription(transcriptionId);
    const segments = transcription.result.segments;
    
    let jsxContent = `// After Effects Caption Import
// Generated by CapEdify
// Auto-generated from transcription

var comp = app.project.activeItem;
if (!comp || !(comp instanceof CompItem)) {
    alert("Please select a composition first.");
} else {
    var textLayer;
    
`;

    segments.forEach((segment, index) => {
      const text = segment.text.replace(/"/g, '\\"').replace(/\n/g, '\\n');
      
      jsxContent += `    // Caption ${index + 1}
    textLayer = comp.layers.addText("${text}");
    textLayer.name = "Caption ${index + 1}";
    textLayer.inPoint = ${segment.start};
    textLayer.outPoint = ${segment.end};
    
    // Basic text properties
    var textProp = textLayer.property("Source Text");
    var textDocument = textProp.value;
    textDocument.fontSize = 48;
    textDocument.fillColor = [1, 1, 1]; // White
    textDocument.strokeColor = [0, 0, 0]; // Black outline
    textDocument.strokeWidth = 2;
    textDocument.justification = ParagraphJustification.CENTER_JUSTIFY;
    textProp.setValue(textDocument);
    
    // Position at bottom center
    textLayer.property("Transform").property("Position").setValue([comp.width/2, comp.height - 150]);
    
`;
    });

    jsxContent += `    alert("Imported ${segments.length} captions successfully!");
}`;

    return jsxContent;
  }

  /**
   * Generate VTT (WebVTT) format
   * Web standard for HTML5 video players
   */
  async exportToVTT(transcriptionId) {
    const transcription = this.getTranscription(transcriptionId);
    const segments = transcription.result.segments;
    
    let vttContent = 'WEBVTT\n\n';
    
    segments.forEach((segment, index) => {
      const startTime = this.formatVTTTime(segment.start);
      const endTime = this.formatVTTTime(segment.end);
      const text = segment.text.trim();
      
      vttContent += `${index + 1}\n`;
      vttContent += `${startTime} --> ${endTime}\n`;
      vttContent += `${text}\n\n`;
    });
    
    return vttContent.trim();
  }

  /**
   * Generate FCPXML format for Final Cut Pro
   */
  async exportToFCPXML(transcriptionId) {
    const transcription = this.getTranscription(transcriptionId);
    const segments = transcription.result.segments;
    
    let fcpxml = '<?xml version="1.0" encoding="UTF-8"?>\n';
    fcpxml += '<!DOCTYPE fcpxml>\n';
    fcpxml += '<fcpxml version="1.8">\n';
    fcpxml += '  <resources>\n';
    fcpxml += '    <format id="r1" name="FFVideoFormat1080p24" />\n';
    fcpxml += '  </resources>\n';
    fcpxml += '  <library>\n';
    fcpxml += '    <event name="Captions">\n';
    fcpxml += '      <project name="Captions Project">\n';
    fcpxml += '        <sequence format="r1">\n';
    fcpxml += '          <spine>\n';
    
    segments.forEach((segment) => {
      const start = segment.start;
      const duration = segment.end - segment.start;
      fcpxml += `            <title duration="${duration}s" start="${start}s" name="${segment.text.replace(/"/g, '&quot;')}" />\n`;
    });

    fcpxml += '          </spine>\n';
    fcpxml += '        </sequence>\n';
    fcpxml += '      </project>\n';
    fcpxml += '    </event>\n';
    fcpxml += '  </library>\n';
    fcpxml += '</fcpxml>';

    return fcpxml;
  }

  /**
   * Generate ASS format for advanced styling
   */
  async exportToASS(transcriptionId) {
    const transcription = this.getTranscription(transcriptionId);
    const segments = transcription.result.segments;
    
    let assContent = '[Script Info]\nTitle: Subtitles\nScriptType: v4.00+\n\n';
    assContent += '[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n';
    assContent += 'Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1\n\n';
    assContent += '[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n';

    segments.forEach((segment) => {
      const start = this.formatTimestampASS(segment.start);
      const end = this.formatTimestampASS(segment.end);
      assContent += `Dialogue: 0,${start},${end},Default,,0,0,0,,${segment.text}\n`;
    });

    return assContent;
  }

  // Helper methods for time formatting
  formatSRTTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 1000);
    
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
  }

  formatVTTTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const ms = Math.floor((seconds % 1) * 1000);
    
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
  }

  formatTimestampASS(seconds) {
    const date = new Date(0);
    date.setSeconds(seconds);
    const hours = date.getUTCHours().toString().padStart(1, '0');
    const minutes = date.getUTCMinutes().toString().padStart(2, '0');
    const secs = date.getUTCSeconds().toString().padStart(2, '0');
    const cs = Math.floor(date.getUTCMilliseconds() / 10).toString().padStart(2, '0');
    return `${hours}:${minutes}:${secs}.${cs}`;
  }

  getTranscription(transcriptionId) {
    if (!this.transcriptionsMap) {
      throw new Error('Transcriptions map not initialized');
    }
    
    const transcription = this.transcriptionsMap.get(transcriptionId);
    if (!transcription) {
      throw new Error('Transcription not found');
    }
    if (!transcription.result) {
      throw new Error('Transcription has no results');
    }

    return transcription;
  }

  /**
   * Universal export method that handles all formats
   * Used by ultra-server for streamlined exports
   */
  async exportTranscription(transcriptionResult, format, filename) {
    try {
      console.log(`🎬 Exporting transcription to ${format.toUpperCase()} format...`);
      
      const segments = transcriptionResult.segments || [];
      const text = transcriptionResult.text || '';
      
      switch (format.toLowerCase()) {
        case 'srt':
          return this.generateSRT(segments, filename);
        case 'jsx':
          return this.generateJSX(segments, filename);
        case 'vtt':
          return this.generateVTT(segments, filename);
        case 'fcpxml':
          return this.generateFCPXML(segments, filename);
        case 'ass':
          return this.generateASS(segments, filename);
        default:
          throw new Error(`Unsupported export format: ${format}`);
      }
    } catch (error) {
      console.error(`❌ Export to ${format} failed:`, error);
      throw error;
    }
  }

  /**
   * Generate SRT format from segments
   */
  generateSRT(segments, filename) {
    let srtContent = '';
    
    segments.forEach((segment, index) => {
      const sequenceNumber = index + 1;
      const startTime = this.formatSRTTime(segment.start);
      const endTime = this.formatSRTTime(segment.end);
      const text = segment.text.trim();
      
      srtContent += `${sequenceNumber}\n`;
      srtContent += `${startTime} --> ${endTime}\n`;
      srtContent += `${text}\n\n`;
    });
    
    return srtContent;
  }

  /**
   * Generate JSX format for After Effects
   */
  generateJSX(segments, filename) {
    let jsxContent = `// After Effects JSX Script for ${filename}\n`;
    jsxContent += `// Generated by CapEdify Ultra-Compression\n\n`;
    jsxContent += `app.beginUndoGroup("Import Captions");\n\n`;
    jsxContent += `var comp = app.project.activeItem;\n`;
    jsxContent += `if (comp && comp instanceof CompItem) {\n`;
    jsxContent += `    var textLayer = comp.layers.addText("${filename} Captions");\n`;
    jsxContent += `    var textProp = textLayer.property("Source Text");\n\n`;
    
    segments.forEach((segment, index) => {
      const startTime = segment.start;
      const endTime = segment.end;
      const text = segment.text.replace(/"/g, '\\"').trim();
      
      jsxContent += `    // Caption ${index + 1}\n`;
      jsxContent += `    textProp.setValueAtTime(${startTime}, "${text}");\n`;
      jsxContent += `    textProp.setValueAtTime(${endTime}, "");\n\n`;
    });
    
    jsxContent += `} else {\n`;
    jsxContent += `    alert("Please select a composition first.");\n`;
    jsxContent += `}\n\n`;
    jsxContent += `app.endUndoGroup();\n`;
    
    return jsxContent;
  }

  /**
   * Generate VTT format for web players
   */
  generateVTT(segments, filename) {
    let vttContent = `WEBVTT\n`;
    vttContent += `NOTE Generated by CapEdify Ultra-Compression for ${filename}\n\n`;
    
    segments.forEach((segment, index) => {
      const startTime = this.formatVTTTime(segment.start);
      const endTime = this.formatVTTTime(segment.end);
      const text = segment.text.trim();
      
      vttContent += `${startTime} --> ${endTime}\n`;
      vttContent += `${text}\n\n`;
    });
    
    return vttContent;
  }

  /**
   * Generate FCPXML format for Final Cut Pro
   */
  generateFCPXML(segments, filename) {
    let fcpContent = `<?xml version="1.0" encoding="UTF-8"?>\n`;
    fcpContent += `<!DOCTYPE fcpxml>\n`;
    fcpContent += `<fcpxml version="1.10">\n`;
    fcpContent += `    <resources>\n`;
    fcpContent += `        <format id="r1" name="FFVideoFormat1080p30" frameDuration="1001/30000s" width="1920" height="1080"/>\n`;
    fcpContent += `    </resources>\n`;
    fcpContent += `    <library location="file:///Users/Shared/">\n`;
    fcpContent += `        <event name="${filename} Captions">\n`;
    fcpContent += `            <project name="${filename} Captions">\n`;
    fcpContent += `                <sequence format="r1" tcStart="0s" tcFormat="NDF" audioLayout="stereo" audioRate="48k">\n`;
    fcpContent += `                    <spine>\n`;
    
    segments.forEach((segment, index) => {
      const duration = segment.end - segment.start;
      const text = segment.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').trim();
      
      fcpContent += `                        <title ref="r2" offset="${this.formatFCPTime(segment.start)}" duration="${this.formatFCPTime(duration)}" start="0s">\n`;
      fcpContent += `                            <text>\n`;
      fcpContent += `                                <text-style ref="ts1">${text}</text-style>\n`;
      fcpContent += `                            </text>\n`;
      fcpContent += `                        </title>\n`;
    });
    
    fcpContent += `                    </spine>\n`;
    fcpContent += `                </sequence>\n`;
    fcpContent += `            </project>\n`;
    fcpContent += `        </event>\n`;
    fcpContent += `    </library>\n`;
    fcpContent += `</fcpxml>\n`;
    
    return fcpContent;
  }

  /**
   * Generate ASS format for advanced subtitle styling
   */
  generateASS(segments, filename) {
    let assContent = `[Script Info]\n`;
    assContent += `Title: ${filename}\n`;
    assContent += `ScriptType: v4.00+\n`;
    assContent += `WrapStyle: 0\n`;
    assContent += `ScaledBorderAndShadow: yes\n`;
    assContent += `YCbCr Matrix: TV.709\n\n`;
    
    assContent += `[V4+ Styles]\n`;
    assContent += `Format: Name, Fontname, Fontsize, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n`;
    assContent += `Style: Default,Arial,20,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1\n\n`;
    
    assContent += `[Events]\n`;
    assContent += `Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n`;
    
    segments.forEach((segment, index) => {
      const startTime = this.formatASSTime(segment.start);
      const endTime = this.formatASSTime(segment.end);
      const text = segment.text.trim();
      
      assContent += `Dialogue: 0,${startTime},${endTime},Default,,0,0,0,,${text}\n`;
    });
    
    return assContent;
  }

  /**
   * Format time for Final Cut Pro XML (in seconds with 's' suffix)
   */
  formatFCPTime(seconds) {
    return `${seconds.toFixed(3)}s`;
  }

  /**
   * Format time for ASS format (H:MM:SS.CC)
   */
  formatASSTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const centiseconds = Math.floor((seconds % 1) * 100);
    
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${centiseconds.toString().padStart(2, '0')}`;
  }
}

module.exports = new ExportServiceSimplified();
