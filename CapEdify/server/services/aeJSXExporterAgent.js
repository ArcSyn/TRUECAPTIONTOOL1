/**
 * AEJSXExporterAgent - Generates final .jsx loader script for After Effects
 * 
 * Features:
 * - Compatible with AE JavaScript engine 2018+
 * - Can load inline array or imported JSON array
 * - Loops segments, creates text layers with inPoint=start, outPoint=end
 * - Applies consistent font size, position, optional fade keyframes
 * - Uses camelCase AE methods per modern syntax
 * - Does not alter existing server/frontend logic - purely additive
 */
class AEJSXExporterAgent {
  constructor() {
    // Default styling configurations
    this.stylePresets = {
      modern: {
        font: 'Montserrat-Bold',
        size: 120,
        color: '#FFFFFF',
        strokeColor: '#000000',
        strokeWidth: 8,
        shadowOpacity: 0.8,
        fadeInDuration: 0.3,
        fadeOutDuration: 0.3
      },
      minimal: {
        font: 'Arial-Bold', 
        size: 100,
        color: '#FFFFFF',
        strokeColor: '#333333',
        strokeWidth: 4,
        shadowOpacity: 0.5,
        fadeInDuration: 0.2,
        fadeOutDuration: 0.2
      },
      bold: {
        font: 'Impact',
        size: 140,
        color: '#FFFF00',
        strokeColor: '#000000',
        strokeWidth: 12,
        shadowOpacity: 1.0,
        fadeInDuration: 0.4,
        fadeOutDuration: 0.4
      },
      podcast: {
        font: 'Source Sans Pro-Regular',
        size: 80,
        color: '#FFFFFF',
        strokeColor: '#1A1A1A',
        strokeWidth: 6,
        shadowOpacity: 0.6,
        fadeInDuration: 0.25,
        fadeOutDuration: 0.25
      },
      cinematic: {
        font: 'Trajan Pro-Regular',
        size: 110,
        color: '#F5F5DC',
        strokeColor: '#2F2F2F',
        strokeWidth: 10,
        shadowOpacity: 0.9,
        fadeInDuration: 0.5,
        fadeOutDuration: 0.5
      }
    };
    
    // Position presets
    this.positionPresets = {
      bottom: { x: 0.5, y: 0.85 },        // Bottom center
      top: { x: 0.5, y: 0.15 },           // Top center  
      center: { x: 0.5, y: 0.5 },         // Center
      bottomLeft: { x: 0.1, y: 0.85 },    // Bottom left
      bottomRight: { x: 0.9, y: 0.85 },   // Bottom right
      topLeft: { x: 0.1, y: 0.15 },       // Top left
      topRight: { x: 0.9, y: 0.15 }       // Top right
    };
  }

  /**
   * Generate main_loader.jsx script for After Effects
   * @param {Array} segments - Transcript segments [{start, end, text}, ...]
   * @param {Object} options - Export options
   * @returns {string} - Complete JSX script content
   */
  generateMainLoader(segments, options = {}) {
    // Merge options with defaults
    const config = {
      style: options.style || 'modern',
      position: options.position || 'bottom',
      enableFades: options.enableFades !== false, // Default true
      enableStroke: options.enableStroke !== false, // Default true
      enableShadow: options.enableShadow !== false, // Default true
      centerAlign: options.centerAlign !== false, // Default true
      exportMode: options.exportMode || 'inline', // 'inline' or 'import'
      filename: options.filename || 'caption_segments.json',
      ...options
    };

    // Get style and position configurations
    const styleConfig = this.stylePresets[config.style] || this.stylePresets.modern;
    const positionConfig = this.positionPresets[config.position] || this.positionPresets.bottom;

    // Generate the JSX script
    const jsxScript = this.buildJSXScript(segments, styleConfig, positionConfig, config);
    
    console.log(`✅ AEJSXExporterAgent: Generated JSX for ${segments.length} segments (${config.style} style)`);
    return jsxScript;
  }

  /**
   * Build the complete JSX script
   */
  buildJSXScript(segments, styleConfig, positionConfig, config) {
    const segmentsData = config.exportMode === 'inline' 
      ? JSON.stringify(segments, null, 8)
      : `JSON.parse($.evalFile("${config.filename}"))`;

    return `// After Effects JSX Caption Loader - Generated by CapEdify Phase 3
// Compatible with After Effects 2018+ JavaScript engine
// Style: ${config.style} | Position: ${config.position}
// Generated: ${new Date().toISOString()}

app.beginUndoGroup("CapEdify Caption Import");

try {
    var comp = app.project.activeItem;
    if (!comp || !(comp instanceof CompItem)) {
        alert("Please select a composition first");
        throw new Error("No composition selected");
    }
    
    // Validation
    if (!comp.width || !comp.height) {
        alert("Invalid composition dimensions");
        throw new Error("Invalid composition");
    }
    
    // Caption segments data
    var captionSegments = ${segmentsData};
    
    // Validate segments
    if (!captionSegments || !captionSegments.length) {
        alert("No caption segments found");
        throw new Error("No caption data");
    }
    
    // Style configuration
    var styleConfig = {
        font: "${styleConfig.font}",
        size: ${styleConfig.size},
        color: ${this.hexToAERGB(styleConfig.color)},
        strokeColor: ${this.hexToAERGB(styleConfig.strokeColor)},
        strokeWidth: ${styleConfig.strokeWidth},
        shadowOpacity: ${styleConfig.shadowOpacity},
        fadeInDuration: ${styleConfig.fadeInDuration},
        fadeOutDuration: ${styleConfig.fadeOutDuration}
    };
    
    // Position configuration
    var positionConfig = {
        x: ${positionConfig.x},
        y: ${positionConfig.y}
    };
    
    // Feature flags
    var features = {
        enableFades: ${config.enableFades},
        enableStroke: ${config.enableStroke},
        enableShadow: ${config.enableShadow},
        centerAlign: ${config.centerAlign}
    };
    
    // Progress tracking
    var totalSegments = captionSegments.length;
    var processedCount = 0;
    
    // Create text layers for each caption segment
    for (var i = 0; i < captionSegments.length; i++) {
        var segment = captionSegments[i];
        
        // Validate segment data
        if (!segment.text || segment.text.trim() === '') {
            continue; // Skip empty segments
        }
        
        if (typeof segment.start !== 'number' || typeof segment.end !== 'number') {
            continue; // Skip invalid timing
        }
        
        if (segment.start >= segment.end) {
            continue; // Skip invalid duration
        }
        
        try {
            // Create text layer
            var textLayer = comp.layers.addText(segment.text.trim());
            textLayer.name = "Caption " + (i + 1) + " (" + segment.start.toFixed(1) + "s-" + segment.end.toFixed(1) + "s)";
            
            // Get text property
            var textProp = textLayer.property("Source Text");
            var textDocument = textProp.value;
            
            // Apply text styling
            textDocument.resetCharStyle();
            textDocument.fontSize = styleConfig.size;
            textDocument.fillColor = styleConfig.color;
            textDocument.font = styleConfig.font;
            textDocument.applyFill = true;
            
            // Apply stroke if enabled
            if (features.enableStroke) {
                textDocument.strokeColor = styleConfig.strokeColor;
                textDocument.strokeWidth = styleConfig.strokeWidth;
                textDocument.applyStroke = true;
            }
            
            // Apply center alignment if enabled
            if (features.centerAlign) {
                textDocument.justification = ParagraphJustification.CENTER_JUSTIFY;
            }
            
            // Update text property
            textProp.setValue(textDocument);
            
            // Position the text layer
            var posX = comp.width * positionConfig.x;
            var posY = comp.height * positionConfig.y;
            textLayer.property("Transform").property("Position").setValue([posX, posY]);
            
            // Set anchor point for proper positioning
            var sourceRect = textLayer.property("Source Text").value.sourceRectAtTime(0, false);
            textLayer.property("Transform").property("Anchor Point").setValue([
                sourceRect.width / 2,
                sourceRect.height / 2
            ]);
            
            // Set timing (convert seconds to AE time)
            textLayer.startTime = segment.start;
            textLayer.outPoint = segment.end;
            
            // Add drop shadow if enabled
            if (features.enableShadow) {
                var dropShadow = textLayer.property("Effects").addProperty("ADBE Drop Shadow");
                dropShadow.property("Opacity").setValue(styleConfig.shadowOpacity * 100);
                dropShadow.property("Direction").setValue(135);
                dropShadow.property("Distance").setValue(15);
                dropShadow.property("Softness").setValue(20);
                dropShadow.property("Shadow Color").setValue([0, 0, 0, 1]);
            }
            
            // Add fade in/out keyframes if enabled
            if (features.enableFades && styleConfig.fadeInDuration > 0 && styleConfig.fadeOutDuration > 0) {
                var opacityProp = textLayer.property("Transform").property("Opacity");
                
                // Fade in
                var fadeInStart = segment.start;
                var fadeInEnd = segment.start + styleConfig.fadeInDuration;
                if (fadeInEnd < segment.end) {
                    opacityProp.setValueAtTime(fadeInStart, 0);
                    opacityProp.setValueAtTime(fadeInEnd, 100);
                }
                
                // Fade out
                var fadeOutStart = segment.end - styleConfig.fadeOutDuration;
                var fadeOutEnd = segment.end;
                if (fadeOutStart > segment.start) {
                    opacityProp.setValueAtTime(fadeOutStart, 100);
                    opacityProp.setValueAtTime(fadeOutEnd, 0);
                }
                
                // Set keyframe interpolation to ease
                for (var k = 1; k <= opacityProp.numKeys; k++) {
                    opacityProp.setTemporalEaseAtKey(k, [
                        new KeyframeEase(0, 50),
                        new KeyframeEase(0, 50)
                    ], [
                        new KeyframeEase(0, 50), 
                        new KeyframeEase(0, 50)
                    ]);
                }
            }
            
            processedCount++;
            
        } catch (segmentError) {
            // Log error but continue processing
            $.writeln("Error processing segment " + (i + 1) + ": " + segmentError.toString());
        }
    }
    
    // Final success message
    var successMessage = "✅ CapEdify Import Complete!\\n\\n" +
                        "📊 Processed: " + processedCount + "/" + totalSegments + " segments\\n" +
                        "🎨 Style: " + "${config.style}" + "\\n" +
                        "📍 Position: " + "${config.position}" + "\\n" +
                        "⏱️ Timing: Frame-accurate to video\\n" +
                        "🎬 Ready for After Effects rendering!";
    
    alert(successMessage);
    
} catch (error) {
    alert("❌ CapEdify Error: " + error.toString());
    $.writeln("CapEdify JSX Error: " + error.toString());
} finally {
    app.endUndoGroup();
}

// Helper function to convert hex color to After Effects RGB array
function hexToAERGB(hex) {
    var r = parseInt(hex.slice(1, 3), 16) / 255;
    var g = parseInt(hex.slice(3, 5), 16) / 255; 
    var b = parseInt(hex.slice(5, 7), 16) / 255;
    return [r, g, b, 1];
}

// Helper function for debugging
function logSegmentInfo(segment, index) {
    $.writeln("Segment " + (index + 1) + ": " + 
             segment.start.toFixed(2) + "s-" + segment.end.toFixed(2) + 
             "s | " + segment.text.substring(0, 50) + 
             (segment.text.length > 50 ? "..." : ""));
}`;
  }

  /**
   * Generate standalone JSON file for import mode
   */
  generateSegmentJSON(segments, filename = 'caption_segments.json') {
    const jsonContent = JSON.stringify(segments, null, 2);
    console.log(`✅ AEJSXExporterAgent: Generated JSON file with ${segments.length} segments`);
    return {
      filename: filename,
      content: jsonContent
    };
  }

  /**
   * Generate SRT file from segments
   */
  generateSRT(segments) {
    let srtContent = '';
    
    segments.forEach((segment, index) => {
      const startTime = this.secondsToSRTTime(segment.start);
      const endTime = this.secondsToSRTTime(segment.end);
      
      srtContent += `${index + 1}\n`;
      srtContent += `${startTime} --> ${endTime}\n`;
      srtContent += `${segment.text.trim()}\n\n`;
    });
    
    console.log(`✅ AEJSXExporterAgent: Generated SRT with ${segments.length} entries`);
    return srtContent.trim();
  }

  /**
   * Generate VTT file from segments
   */
  generateVTT(segments) {
    let vttContent = 'WEBVTT\n\n';
    
    segments.forEach((segment, index) => {
      const startTime = this.secondsToVTTTime(segment.start);
      const endTime = this.secondsToVTTTime(segment.end);
      
      vttContent += `${index + 1}\n`;
      vttContent += `${startTime} --> ${endTime}\n`;
      vttContent += `${segment.text.trim()}\n\n`;
    });
    
    console.log(`✅ AEJSXExporterAgent: Generated VTT with ${segments.length} entries`);
    return vttContent.trim();
  }

  /**
   * Convert hex color to After Effects RGB array format
   */
  hexToAERGB(hex) {
    const r = parseInt(hex.slice(1, 3), 16) / 255;
    const g = parseInt(hex.slice(3, 5), 16) / 255;
    const b = parseInt(hex.slice(5, 7), 16) / 255;
    return `[${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)}, 1]`;
  }

  /**
   * Convert seconds to SRT time format (HH:MM:SS,mmm)
   */
  secondsToSRTTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const millis = Math.floor((seconds % 1) * 1000);
    
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${millis.toString().padStart(3, '0')}`;
  }

  /**
   * Convert seconds to VTT time format (HH:MM:SS.mmm)
   */
  secondsToVTTTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    const millis = Math.floor((seconds % 1) * 1000);
    
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${millis.toString().padStart(3, '0')}`;
  }

  /**
   * Validate segments array
   */
  validateSegments(segments) {
    if (!Array.isArray(segments)) {
      throw new Error('Segments must be an array');
    }
    
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      
      if (!segment.text || typeof segment.text !== 'string') {
        throw new Error(`Segment ${i + 1}: Invalid or missing text`);
      }
      
      if (typeof segment.start !== 'number' || segment.start < 0) {
        throw new Error(`Segment ${i + 1}: Invalid start time`);
      }
      
      if (typeof segment.end !== 'number' || segment.end <= segment.start) {
        throw new Error(`Segment ${i + 1}: Invalid end time`);
      }
    }
    
    return true;
  }

  /**
   * Get available style presets
   */
  getStylePresets() {
    return Object.keys(this.stylePresets);
  }

  /**
   * Get available position presets
   */
  getPositionPresets() {
    return Object.keys(this.positionPresets);
  }
}

module.exports = new AEJSXExporterAgent();