#!/usr/bin/env node

/**
 * CaptionFlow CLI - Enhanced SRT to JSX Converter
 * Phase 1 Implementation: SRT ‚Üí JSX Engine
 * 
 * Usage:
 *   node jsx-export-cli.js input.srt [options]
 * 
 * Options:
 *   --style modern|minimal|bold     Style template (default: modern)
 *   --scenes                        Split into scene files
 *   --gap 2.0                      Scene gap threshold in seconds
 *   --project "My Project"         Project name
 *   --output ./output              Output directory
 */

const fs = require('fs').promises;
const path = require('path');

// Since we're running from scripts/, we need to reference the server relative to that
const jsxExportServicePath = path.join(__dirname, '..', 'CapEdify', 'server', 'services', 'jsxExportService.js');

// Check if the service exists, if not create a simple version
let jsxExportService;
try {
  jsxExportService = require(jsxExportServicePath);
} catch (error) {
  console.log('‚ö†Ô∏è  JSX Export Service not found, using built-in version');
  // Simple built-in JSX export for demo
  jsxExportService = {
    async exportToJSX(transcriptionId, options) {
      const { srtContent, projectName = 'Caption Project', styleName = 'modern' } = options;
      
      if (!srtContent) {
        return { success: false, error: 'No SRT content provided' };
      }

      // Simple SRT parser
      const captions = this.parseSRT(srtContent);
      const jsxCode = this.generateBasicJSX(captions, projectName, styleName);
      
      return {
        success: true,
        data: jsxCode,
        metadata: {
          captionCount: captions.length,
          totalDuration: captions.length > 0 ? captions[captions.length - 1].endTime : 0,
          style: styleName,
          sceneMode: false
        }
      };
    },

    parseSRT(srtContent) {
      const captions = [];
      const blocks = srtContent.trim().split(/\n\s*\n/);
      
      for (const block of blocks) {
        const lines = block.trim().split('\n');
        if (lines.length >= 3) {
          const index = parseInt(lines[0]);
          const timeRange = lines[1];
          const text = lines.slice(2).join(' ');
          
          // Parse time format: 00:00:10,500 --> 00:00:13,240
          const timeMatch = timeRange.match(/(\d{2}):(\d{2}):(\d{2}),(\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2}),(\d{3})/);
          if (timeMatch) {
            const startTime = this.parseTime(timeMatch[1], timeMatch[2], timeMatch[3], timeMatch[4]);
            const endTime = this.parseTime(timeMatch[5], timeMatch[6], timeMatch[7], timeMatch[8]);
            
            captions.push({
              id: index,
              startTime,
              endTime,
              text: text.replace(/<[^>]*>/g, ''), // Remove HTML tags
              duration: endTime - startTime
            });
          }
        }
      }
      
      return captions;
    },

    parseTime(hours, minutes, seconds, milliseconds) {
      return parseInt(hours) * 3600 + 
             parseInt(minutes) * 60 + 
             parseInt(seconds) + 
             parseInt(milliseconds) / 1000;
    },

    generateBasicJSX(captions, projectName, styleName) {
      return `// After Effects Caption Script - ${projectName}
// Generated by CaptionFlow CLI
// Style: ${styleName}

function addCaptions() {
    var comp = app.project.activeItem;
    
    if (!comp || !(comp instanceof CompItem)) {
        alert("Please select a composition first.");
        return;
    }
    
    app.beginUndoGroup("Add Captions");
    
    try {
        var captions = ${JSON.stringify(captions, null, 8)};
        
        for (var i = 0; i < captions.length; i++) {
            var caption = captions[i];
            var textLayer = comp.layers.addText(caption.text);
            textLayer.name = "Caption " + (i + 1);
            
            // Set timing
            textLayer.inPoint = caption.startTime;
            textLayer.outPoint = caption.endTime;
            
            // Apply ${styleName} styling
            var textProp = textLayer.property("Source Text");
            var textDocument = textProp.value;
            
            ${styleName === 'modern' ? `
            textDocument.font = "Arial-Bold";
            textDocument.fontSize = 65;
            textDocument.fillColor = [1, 1, 1];
            textDocument.strokeColor = [0, 0, 0];
            textDocument.strokeWidth = 3;
            ` : styleName === 'minimal' ? `
            textDocument.font = "Helvetica-Light";
            textDocument.fontSize = 48;
            textDocument.fillColor = [1, 1, 1];
            ` : `
            textDocument.font = "Impact";
            textDocument.fontSize = 72;
            textDocument.fillColor = [1, 1, 0];
            textDocument.strokeColor = [0, 0, 0];
            textDocument.strokeWidth = 4;
            `}
            
            textDocument.justification = ParagraphJustification.CENTER_JUSTIFY;
            textProp.setValue(textDocument);
            
            // Position at bottom center
            textLayer.property("Position").setValue([comp.width/2, comp.height * 0.85]);
            
            ${styleName === 'modern' ? `
            // Add fade-in animation
            var opacity = textLayer.property("Opacity");
            opacity.setValueAtTime(textLayer.inPoint, 0);
            opacity.setValueAtTime(textLayer.inPoint + 0.3, 100);
            opacity.setValueAtTime(textLayer.outPoint - 0.3, 100);
            opacity.setValueAtTime(textLayer.outPoint, 0);
            ` : ''}
        }
        
        app.endUndoGroup();
        alert("Successfully added " + captions.length + " captions with ${styleName} style!");
        
    } catch (error) {
        app.endUndoGroup();
        alert("Error adding captions: " + error.toString());
    }
}

// Execute the function
addCaptions();
`;
    }
  };
}

// Parse command line arguments
function parseArgs() {
  const args = process.argv.slice(2);
  const options = {
    inputFile: null,
    styleName: 'modern',
    sceneMode: false,
    gapThreshold: 2.0,
    projectName: 'Caption Project',
    outputDir: './output'
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    
    if (arg.startsWith('-')) {
      switch (arg) {
        case '--style':
          options.styleName = args[++i];
          break;
        case '--scenes':
          options.sceneMode = true;
          break;
        case '--gap':
          options.gapThreshold = parseFloat(args[++i]);
          break;
        case '--project':
          options.projectName = args[++i];
          break;
        case '--output':
          options.outputDir = args[++i];
          break;
        case '--help':
          showHelp();
          process.exit(0);
          break;
        default:
          console.error(`Unknown option: ${arg}`);
          process.exit(1);
      }
    } else if (!options.inputFile) {
      options.inputFile = arg;
    }
  }

  return options;
}

function showHelp() {
  console.log(`
üé¨ CaptionFlow CLI - Enhanced SRT to JSX Converter

Usage:
  npm run jsx-export input.srt [options]

Options:
  --style <template>     Style template: modern, minimal, bold (default: modern)
  --scenes              Split into scene files based on gaps
  --gap <seconds>       Scene gap threshold in seconds (default: 2.0)
  --project <name>      Project name (default: "Caption Project")
  --output <dir>        Output directory (default: ./output)
  --help               Show this help message

Examples:
  # Basic JSX export
  npm run jsx-export examples/demo_captions.srt --style modern

  # Scene-based export with custom gap
  npm run jsx-export examples/demo_captions.srt --scenes --gap 3.0 --project "My Video"

  # Export to specific directory
  npm run jsx-export examples/demo_captions.srt --output ./ae-scripts --style bold

After Effects Usage:
  1. Open After Effects
  2. Create or select a composition
  3. File ‚Üí Scripts ‚Üí Run Script File
  4. Select the generated .jsx file
  5. Captions will be added as text layers with timing and styling
`);
}

async function ensureOutputDir(outputDir) {
  try {
    await fs.mkdir(outputDir, { recursive: true });
  } catch (error) {
    console.error(`Error creating output directory: ${error.message}`);
    process.exit(1);
  }
}

async function readSRTFile(filePath) {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    return content;
  } catch (error) {
    console.error(`Error reading SRT file: ${error.message}`);
    console.error(`Make sure the file exists: ${filePath}`);
    process.exit(1);
  }
}

async function writeJSXFiles(outputDir, jsxData, projectName, sceneMode) {
  try {
    if (sceneMode && typeof jsxData === 'object') {
      // Multiple scene files
      console.log(`Writing ${Object.keys(jsxData).length} scene files...`);
      
      for (const [filename, content] of Object.entries(jsxData)) {
        const filePath = path.join(outputDir, filename);
        await fs.writeFile(filePath, content, 'utf-8');
        console.log(`‚úì ${filename}`);
      }
      
      console.log(`\n‚ú® Scene files exported successfully to ${outputDir}`);
    } else {
      // Single JSX file
      const filename = `${projectName.replace(/\s+/g, '_')}.jsx`;
      const filePath = path.join(outputDir, filename);
      await fs.writeFile(filePath, jsxData, 'utf-8');
      
      console.log(`‚ú® JSX file exported successfully: ${filename}`);
      console.log(`üìÇ Location: ${path.resolve(filePath)}`);
    }
  } catch (error) {
    console.error(`Error writing JSX files: ${error.message}`);
    process.exit(1);
  }
}

async function main() {
  const options = parseArgs();
  
  if (!options.inputFile) {
    console.error('‚ùå Error: Please provide an SRT file to convert');
    console.log('Use --help for usage information');
    console.log('Example: npm run jsx-export examples/demo_captions.srt');
    process.exit(1);
  }

  if (!['modern', 'minimal', 'bold'].includes(options.styleName)) {
    console.error('‚ùå Error: Style must be one of: modern, minimal, bold');
    process.exit(1);
  }

  console.log('üé¨ CaptionFlow CLI - Enhanced SRT to JSX Converter');
  console.log(`üìÅ Input: ${options.inputFile}`);
  console.log(`üé® Style: ${options.styleName}`);
  console.log(`üìö Scene Mode: ${options.sceneMode ? 'enabled' : 'disabled'}`);
  if (options.sceneMode) {
    console.log(`‚è±Ô∏è  Scene Gap: ${options.gapThreshold}s`);
  }
  console.log(`üìÇ Output: ${options.outputDir}`);
  console.log('');

  // Ensure output directory exists
  await ensureOutputDir(options.outputDir);

  // Read SRT file
  console.log('üìñ Reading SRT file...');
  const srtContent = await readSRTFile(options.inputFile);

  // Parse and export
  console.log('üîÑ Converting to JSX...');
  const result = await jsxExportService.exportToJSX(null, {
    srtContent,
    projectName: options.projectName,
    styleName: options.styleName,
    sceneMode: options.sceneMode,
    gapThreshold: options.gapThreshold
  });

  if (!result.success) {
    console.error(`‚ùå Export failed: ${result.error}`);
    process.exit(1);
  }

  // Write JSX files
  await writeJSXFiles(
    options.outputDir, 
    result.data, 
    options.projectName, 
    options.sceneMode
  );

  // Show summary
  console.log('');
  console.log('üìä Export Summary:');
  console.log(`   Captions: ${result.metadata.captionCount}`);
  console.log(`   Duration: ${result.metadata.totalDuration.toFixed(1)}s`);
  console.log(`   Style: ${result.metadata.style}`);
  console.log(`   Scenes: ${result.metadata.sceneMode ? 'Yes' : 'No'}`);
  
  console.log('');
  console.log('üéâ Done! Import the JSX file(s) into After Effects:');
  console.log('   1. Open After Effects');
  console.log('   2. Create/select a composition');
  console.log('   3. File ‚Üí Scripts ‚Üí Run Script File');
  console.log('   4. Select the .jsx file');
  console.log('');
  console.log('üîó Next steps: Check JSX_EXPORT_GUIDE.md for more details');
}

// Handle errors gracefully
process.on('uncaughtException', (error) => {
  console.error(`‚ùå Unexpected error: ${error.message}`);
  process.exit(1);
});

process.on('unhandledRejection', (error) => {
  console.error(`‚ùå Unhandled promise rejection: ${error.message}`);
  process.exit(1);
});

// Run the CLI
if (require.main === module) {
  main().catch(error => {
    console.error(`‚ùå CLI Error: ${error.message}`);
    process.exit(1);
  });
}

module.exports = { parseArgs, showHelp, main };
